后台实现:
	把我们后台查询到的数据格式设计成为,前台预设的格式
	
	需求分析:
	1,	分类:指的是三级分类,同时需要name
			分类:{id,name}
		品牌:
			品牌:{id,name,image}
	2,es索引库存在品牌id和分类id
	3,根据品牌id和分类id去聚合(term,mach,mach_all)
	
	操作步骤:
	 builder.addAggregation(AggregationBuilders.terms(categoryName).field("cid3"));
	 
	 builder.addAggregation:表示开始聚合
	 AggregationBuilders.terms: terms词条
	 categoryName:对应字段--可自定义
	 field("cid3"): 去根据cid3聚合
	 
	 查询结果分析:
	 "aggregations": {
    "cid3Name": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": 76,
          "doc_count": 182
        }
      ]
    }
  }
	aggregations:包装到这里类
	buckets:类中的桶
	
	java代码:
	AggregatedPage<Goods> search1 = (AggregatedPage<Goods>) goodsRepository.search(builder.build());
	
	AggregatedPage:其实就是aggregations类(的集合)->
	因为builder.build()构造器有多个条件,所以返回search1是多个结果的集合
	
	"cid3Name":就是上面自定义的名字 categoryName
	
	解析:
	LongTerms categoryAgg = (LongTerms) search1.getAggregation(categoryName);
	从search1中获取名字叫做categoryName这个(aggregations包装类)的所有值,转型为Long类型
	
	解析:
	categoryAgg.getBuckets().forEach(bucket -> {
            Long categoryId =(Long)bucket.getKey();
	拿到我所需的桶,然后循环桶内数据,获取
	
	
	4,然后需要在pageresult 页面返回类中添加 两个属性categoryList brandList 这样才能携带回前台
	5,注意:pageresult因为是公共类,如果写入会污染,
		所以我们增加一个拓展类searchResult
		